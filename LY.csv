纯面向对象的脚本语言,,,,,
一个文件就是一个类，类名就是文件名,,,,,
类似于python的以tab或固定空格数来区分是否结束,"只能使用tab或space其中之一，默认是tab，可以用Setting.setBlockToken(“ “, 4) 或者(“\t”, 1)",,,,
,"不是代码块的概念，而是应该写在一行，通过tab等可以分行来写，并确认结束
if a == 3: print(a)
if a == 4: 
    print(""b"")
if a == b and
    c == d:
    print(""e"")",,,,
可以使用;分隔语句，也可以不用，多用于nokey的类或者map等,,,,,
值类型,"数字Num（64位整数或浮点），标记Bool(true, false)，函数Func，任意类型Any，无类型Void(null)；文本Str；自定义类Class，扩展数据ExtendedData；",,,,
,前4个是基本类型，概念和lua相同；,,,,
,任意类型和无类型只在函数的值类型中使用；,,,,
,"所有类型其实也是类，都可以有静态函数或者实例函数，
如数字可以 local a << 3.2 local b << a.floor_() 也能直接(23.4).floor_()
字符串也可以""abc"".append_(""efd"")
Func有 local a << []() a.bindOwner/bindData 等",,,,
,也是因为所有的类型都是类，所以可以用类型名称进行数据转换，如Num("12") Str(23) Bool可以把非0非空非false转化成true Str和Num可以对类实例使用，调用其toString_ toNumber_,,,,
,Num数字可以用I表示为整数 如 123i 否则Num自动判断，整数效率会更高；,,,,
,文本类型是基本类型，但也是类，指针实现意味着一改全改，但是是常量不可变，文本可用"" '' 也可以用’’,,,,
,自定义类就是类，用指针实现,,,,
,扩展数据是由底层扩展而来的数据，如同lua Userdata,,,,
操作符,"算术操作符：+(加)、-(减)、*(乘)、/(除)、^(乘幂)、%(取余)、-(单目负)  用于整数和浮点数
",,,,
,"比较操作符 < 小于  > 大于  <= 小于等于 >= 大于等于  == 等于 != 不等于 类似perl 用于数字，文本，等于不等于能用于所有类型
",,,,
,大于，小于，大于等于，小于等于，等于，不等于,,,,
,赋值操作符不再是 = 而是 << ，返回右边的值，所以可以 a << b << 1 这样连续赋值,,,,
,逻辑符号：&& || ! 短路型，返回true false,,,,
,没有位操作符，位操作可以用内置类Bin，如local Bin.Lshift(12) ,,,,
,算术符号的双目都有赋值操作符，如 <<+ <<- <<* <</ <<^ <<%，没有++ -- ,local b << a.replace_(),,,
,?操作符类似于switch，用法 ?age ?< 10 : 14 ?<= 20 : 34 : 45 最后一个：后为默认值，可用于实现三目 ? age ?!= null : true : false,,,,
,.操作符等于[""] 如a.b a["b"] 类似lua,,,,
,"逗号操作符的优先级高于赋值操作，可将多个值组合在一起，然后进行计算，如 a,b << (2,3) + (4,1)   a,b <<+ 3,3   a,b = -(a, b)",,,,
,"括号操作符有两种 （）{} 在（）中的下一层必须是{} {}中的下一层必须是（）
如 a + (b - {c * d})",,,,
,大多数操作符都是全局函数,,,,
操作符重载,算数操作符（包括其赋值操作符）和比较操作符可以重载 方法是以~加上符号为函数名 如~+ << [](Num a)return 1,,,,
键名的写法不同可导致值的类型不同：,"如果名字前带“_”则表示私有（也能被子类看到），否则为公有：_name, name",,,,
,"如果名字首字母为小写，则为对象持有，大写为类持有 _name, GetName, NAME_TYPE",,,,
,类持有时，如果第二个字母是小写，则对象可以使用，否则（大写或下划线）只类本身可以使用（静态） GetName NAME_TYPE,,,,
,对象持有的都是非const的，类持有的除了第二个字母是下划线的以外，都是const S_personNum,,,,
,"键名如果以_结尾，则他必须是一个函数，并且在debug中会检测：函数不能改变self的任何属性，只在生成时有效，如果把这样的函数传给没有以_结尾的键值依然不能改变，反过来一样
这也就是因此内建函数直接改变自身的不加_但不改变自身而是将结果return的都会加_
但这个对类函数显然不起作用，所以类函数不能加，因为类函数没有self",,,,
,一个函数，如果以_结尾，则是一个静态函数，而不以这个结尾的，会自动传入self指针，如果以~结尾则debug中会检测：函数不能改变self的任何属性，只在生成时有效，如果把这样的函数传给没有以~结尾的键值依然不能改变，反过来一样，如GetName是一个对象函数，self.GetName()，GetName_则为静态函数 Class.GetName_,,,,
临时变量,定义在函数里，前面必须local,,,,
,包括作为函数参数的变量在内，临时变量首字母小写则为变量，首字母大写（一般应该全大写）则为const常量,,,,
,临时变量可以通过本地变量表找到 local a << 1 LOCAL["a"]可以给a赋值和获取a的值 LOCAL是一个堆栈，可以被覆盖,,,,
,同时，全局变量（主要是内置函数）可以用GLOBAL["print"],,,,
逻辑,循环只有repeat: ...， for ... in ...: ... ，循环中有break，continue；选择为if ..: .. elif ..: .. else ..，有goto语句，配合target_lable:使用，但要求必须在同一个函数里面，且goto必须在target_lable的前面,,,,
,for in 后面放置each range等全局函数 each是迭代器，range如同python，可以自定义函数,,,,
函数,"写法为 键名 = [返回值类型](参数类型 参数) 如：AddPerson << [Bool, Str](Str sname, Num age)",,,,
,函数的参数类型可以在debug模式检测类型是否满足，不满足会报错，可以多态，即父类是即可,,,,
,参数类型可以是基本类或自定义类，自定义类必须是本类最前require或者extend过来的类名,,,,
,"函数使用 AddPerson(""wang"", 15)",,,,
,"函数可以使用upvalue，需要用在函数中声明，写upvalue c, d导入外层的值， Get << [](Int a)  upvalue b return a + b",,,,
,重载的函数后面必须加override，否则会报错，如 Get << [](Int a) override ,,,,
,父类函数后面加abstract 为抽象函数，子类需要实现，后面必须加 implement，否则报错,,,,
,父类函数后加final 则子类不能继承 一个函数中 implement abstract override 只能有一个出现 final不能和abstract同时出现,,,,
,"临时函数可以有，如果是个参数可以用加括号的方式避免冲突，换行时注意多了一个tab
local callback = []()
	return 0

GetCallback(callback, 0)

GetCallback(([]() return 0), false)

GetCallback([](Num a, Bool b)
		if a == 12:
			return 0
		else:
			return a
	, false)",,,,
类,当导入一个文件的时候就等于生产了一个类，写法 require Layer "../.." 其中Layer就是类名,,,,
,类使用()操作符来实例化，如 local a << Layer() 也可以后面加参数 如 local a << Layer(12) 此时会调用__init，带参数需要自己定义__init << [](Int a),,,,
,类被释放掉时候会调用__release函数，可自定义，不能带参数,,,,
,"类的第一行可以指定类的类型，如果放在中间，则会把前面的定义的数据清除掉
set tree 使用hash树（unorder map）来储存类中内容，可以增减类中的项
set nokey 让类的属性不能是任何值，而是随着数量从1递增，可增加查找效率，树不用hash直接比较地址的值
set noins 让类不能产生对象，也就是没有也不调用生产对象的__init和释放的__release函数，并且所有键都是类持有
同时设置多个要写在一行 如 set noins nocheck
实质上就是改变类的超类",,,,
,超类类似于元表，但所有类共用，用于类的一些基本操作，[] ()等，可以通过set改变，如上所述最多八种，需要时才产生,,,,
,没有函数多态，同样名字的函数会覆盖掉前面的,,,,
,继承 类可以继承另一个类 写法 inherit "../.." ，可以多重继承，如果有重复的键值会覆盖掉前面的，有set的类不可以继承于别的类 继承也必须写在第一行 有super属性指向父类，便于重载后使用原有函数,,,,
,如果继承自一个extended data 则使用 inherit XXX 来继承 如：inherit Ex.Layer 此时本类在new的时候会调用extended写在c层的初始化函数，回收时使用c层的结束函数；但不可多重继承扩展数据 有set的类不可以继承于别的类 extend下面可以跟着inherit 多重继承,,,,
,继承的实质是复制父类所有的类持有的键，除了超类（超类用指针指向），对象生成就是复制所有父类中的对象持有属性，然后调用__init，然后里面有指向类的指针,,,,
,"函数中使用self来表示对象自身，所有对象持有的项，需要self，如self._name
",,,,
,类的super表指向其父类，但不能直接使用super，如果需要使用父类的函数，则需要使用call函数，同时把self指针和参数传入，子类可以使用父类的私有方法，但父类的对象都不成，原因是self指针和一般对象指针的区别,,,,
,弱继承，不是真的继承另一个类，而只是让其在检测多态时可以通过：写法： similar "../..",,,,
,类中__run函数可以在类定义的时候执行，不能使用类中的对象持有变量，其参数为命令行或者require后所带的参数,,,,
,"引用出来的类也可以继承，Layer.EXTEND__(),弱继承SIMILAR__，添加或修改其中元素MODIFY__ 删除元素DELETE__ 内存分配MEMSET__ 但这些尽量不要在release模式中使用，因为会把类的容器从固定大小变成可变大小的hash",,,,
,一个类是一个列表，里面可以放多个函数，包括静态函数，实例函数，结构体，类可以产生实例，实例对应一个c的实例和一个LY的类,,,,
扩展数据,"可以从C层用函数扩展来自c或者c++的函数在ly中使用，
setClass0到9设置一个类，参数：类名，父类的名字，初始化函数，结束函数（可为null），返回LYClass（id），如下
void ly_Layer_create()
{
    //lyStr和lyInt表示从堆栈中取出数据并检查，参数1是堆栈中第几个，第二个参数是默认值，lyClass第二参数是加入到ly class中的类型名称，第三个才是默认
    lyReturnPtr(Layer->create(lyStr(1), lyInt(2, 0),  lyClass(3, “Layer”));
}
setClass(""Layer"", ""Node"", ly_Layer_create, nullptr);
getClass获得一个设置了的类LYClass，参数为名称",,,,
,"setFunction 参数为LYClass，函数名，函数指针，返回类型，（参数）（0到9代表几个参数）函数指针为自定义的一个类对象（Static没有）和0到9为参数数量的类 参数是万能指针 返回值为空 内部返回值传给LYReturn就好 不能调用两次LYReturn LYReturn有多种 如
LYReturnInt, Float, Str, Ptr, Bool等
void ly_Layer_getPositionX(void* sender, void* d1)
{
    LYReturnInt((Layer*)sender->getPositionX((int*)d1));
}
setStaticFunction0到9 静态函数，不用调用对象本身
setConstValue 设置值 用于设置常量 参数 LYClass，属性名，值",,,,
,"调用function的方式 
LYFunc func1 = nullptr; 
void Layer_callback(void* d1)
{
    LYLoadFunc(func1)((int)d1);
}
void ly_Layer_setCallback(void* sender, void* d1)
{
    func1 = (LYFunc)d1;
    (Layer*)sender->setCallback((Layer*)sender, Layer_callback);
}

或者用lambda也可以",,,,
,"setStruct 设置一个结构体 可以用setAttribute设置其属性 还有getStruct
setAttribute 参数 LYStruct，属性名，属性类型",,,,
,可以直接用local a << Ex.Layer(str，age) 来使用类或结构体，或者将LY层的类继承于他，使用Ex.Layer.TYPE 使用定义的常量,,,,
模块,在类（文件）中定义类，模块就是类中类，其实任何的类也是一段文本，class "类内容" ，可以用{}取代””，便于代码管理和解决符号冲突（{}内可以有{}），并且({})可以简化成{}，如Map({内容})，可以包装为 Map{内容},,,,
,如同Map{内容}这种里面的处理方式是：把两段文本加在一起然后放入class命令中，前一段表明了类的继承等属性，后一段就是自定义的数值,,,,
,{{}}也用来表示文本，并且可以多行，有几个{就到几个}结束，可以这样使用{{ a{b}}}，则a{b}都为文本,,,,
,可以给一个类中类命名 local layer << class{_a = 3},,,,
,文本中用$(abc)赋值,,,,
官方自带容器,不可修改键Array{1; 2; 3} Table{a = 1; b = 2} Enum{a; b} 可修改添加删除键 Set{a; b} Map{},,,,
,"使用中括号[]，和分号;（没有分号则表示角标）可以表示Array，如[1;3]  [1;]，可以享受Array的操作符，如：
[a; b] = [3; 5] + [2; 7]  可用于多返回值
return [a; b]",,,,
,有Unique（a）使得值在赋值的时候让前一个变量为空,,,,
debug模式,"debug: 后面内容只有debug模式下才响应 比如
debug:
      if a: return 0",,,,
契约式编程,"函数可以这样写：[Num a{a < 20}](Str s{names.have_(s)}, Num n{10 < n and n < 100}) ，{}是一个模块，传入的参数和导出的结果需要满足这些，release下不响应",,,,
多线程,能否用步进实现detach,,,,
异常,try(function) error finally([]()),,,,
垃圾回收机制,,,,,
注释,用--单行注释；--[[]]是多行注释，直到遇到另一个]]结束；几个[就遇到几个]结束,,,,
,c一样的注释方式 // 和 /*  */,,,,
